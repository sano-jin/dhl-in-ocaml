#+title: A POC of Directed HyperLMNtal 
#+author: Jin SANO

* About
  A simple implementation of calculus model Directed HyperLMNtal.
  
* Syntax
  #+NAME: Syntax of Directed HyperLMNtal
  #+begin_src ocaml
    (* argument of an atom *)
    type arg =
      | Atom of string * arg list  (* atom. e.g. a(X, Y) *)
      | Link of string             (* link. e.g. X *)

    (* process *)
    type proc = 
      | Zero
      | Ind of string option * arg  (* indirection. e.g. X -> a(Y) *)
      | Mol of proc * proc          (* molecule. e.g. (P, Q) *)  
      | New of string * proc        (* link creation. e.g. \X.P *)
      | Rule of proc * proc         (* rule. e.g. P :- Q. *)
  #+end_src

* VM
  #+begin_src ocaml
    (* node *)
    type atom =
      | SymbolAtom of string * node_ref list
      | Ind of node_ref
     and node_ref = (int, int, atom) ref  (* (address, indeg, atom) *)

    let null = ref (0, SymbolAtom ("Null", []))

    (* atom list *)
    type atom_list = node_ref list

    (* atom register *)
    type atom_reg = node_ref list

    (* indeg register *)
    type indeg_reg = (int, int) list     (* (address, indeg) list *)

    (* instruction *)
    type inst =
      | FindAtom of string * int * int   (* FindAtom (atomName, arity) *)
      | Neq of int * int                 (* Neq (atom_reg_i_1, atom_reg_i_2) *)
      | Eq of int * int                  (* Eq (atom_reg_i_1, atom_reg_i_2) *)
      | Deref of int * int               (* Deref (atom_reg_i, link_i) *)
      | IndegLe of int * int             (* IndegLe (atom_reg_i, indeg) *)
      | IndegEq of int * int             (* IndegEq (atom_reg_i, indeg) *)
      | Skip
  #+end_src
  
  
  
  
* Instruction
  
    
  

  
