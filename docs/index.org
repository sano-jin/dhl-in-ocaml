#+title: DHL in OCaml
#+subtitle: A minimal interpreter of a language based on graph rewriting
#+author: Jin SANO
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+OPTIONS: ^:nil


* About
  A minimal implementation of a graph rewriting language Directed HyperLMNtal.

** Getting Started
*** Prerequisites
    - [[https://opam.ocaml.org/][opam]]

*** Installation
  #+NAME: Installation
  #+BEGIN_SRC sh
    git clone https://github.com/sano-jin/dhl-in-ocaml
    cd dhl-in-ocaml
    opam install .
    opam exec -- dune build
  #+END_SRC

** Usage

  #+NAME: Usage
  #+BEGIN_SRC sh :dir ../ :exports both :results code :cache yes
    opam exec -- dune exec dhl -- example/append.dhl
  #+END_SRC

  #+RESULTS[e0c57b8f070978062c17c899b19171f1a61edb52]: Usage
  #+begin_src sh
  0: append(cons(a, cons(b, nil)), cons(c, nil))
  1: cons(a, append(cons(b, nil), cons(c, nil)))
  2: cons(a, cons(b, append(nil, cons(c, nil))))
  3: cons(a, cons(b, L0)). L0 -> L1. L1 -> cons(c, nil)
  Final state: cons(a, cons(b, cons(c, nil)))
  #+end_src

  

* 実装の概要
  500 LOC 程度の非常に小さいプログラムである
  （ことを目指している）
  
** LOC
  #+NAME: directory
  #+BEGIN_SRC sh :exports results :results code :cache yes :dir ../ 
    cd src && ../scripts/cloc.sh "*.ml *.mll *.mly" | tail -n 18
  #+END_SRC

  #+RESULTS[7e2b07c6dea30eca900b78fc802cb319d86aca97]: directory
  #+begin_src sh
  File                             blank        comment           code
  -------------------------------------------------------------------------------
  match.ml                            16             20             93
  util.ml                             24              3             63
  parser.mly                          20             12             59
  breakdown.ml                        19             19             55
  pushout.ml                           6              2             51
  dump.ml                             10             13             48
  link_check.ml                       16             11             39
  main.ml                              7              7             39
  alpha.ml                            14             11             34
  lexer.mll                           10              8             34
  vm.ml                               14             16             34
  eval.ml                              5              5             13
  syntax.ml                            2              3              9
  -------------------------------------------------------------------------------
  SUM:                               163            130            571
  -------------------------------------------------------------------------------
  #+end_src

** Dependencies

   #+name: dependencies
   #+begin_src sh :dir ../ :exports none :cache yes
     python3 ../scripts/dep_graph.py ../src | dot -Tsvg > output.svg
   #+end_src
   
   #+RESULTS: dependencies
   
   [[./output.svg]]
   
** プログラムの簡単な解説

   
   
*** Utility functions 
   - util.ml		:: Some utility functions

*** Compiler

**** Lexical/Syntax analysis
     - syntax.ml	:: The abstract syntax definition
     - lexer.mll	:: Defines a token for lexing
     - parser.mly 	:: Defines a grammar for parsing

**** Semantic analysis
     - alpha.ml		:: Convert local link names to fresh ids and partition atoms and rules
     - link_check.ml	:: Collect link information and check them
     - breakdown.ml	:: Check rule conditions and break down atoms

*** VM
    - vm.ml		:: Type definition of an atom and pretty printer for its multi-set
    - match.m		:: Perform graph pattern matching
    - pushout.ml	:: Generate and push atoms
    - eval.ml		:: The one step reducer

*** Repl
    - main.ml		:: File loader and the main execution loop

      
* アトムのメモリ管理に関して
  性能を出すためには，局所リンクでマッチしたアトムや Indirection アトム
  （自由リンクでマッチしてシンボルアトムを置き換える）を毎回アトムリストから削除するよりも，
  Void アトムで更新して，マッチングの際にアトムリストからトラバースする時にアトムリストから取り除き，
  メモリ領域を解放してやる方が良いかもしれない

  現状の方針
  - Indirection アトムはアトムリストに登録しない
  - 局所リンクでマッチしたアトムは毎回アトムリストから除去する
    
** アトムが持つべき情報

*** シンボルアトムの持つべき情報
    - アトム名
    - 引数のリンク（ポインタ）を m 本
    - 他のアトムからの被参照数
      - アトムリストからの参照はカウントしない
      - アトムリストからは常に辿れるはず（べき）なので

*** Indirection アトムの持つべき情報
    - 引数のリンクを一本（ポインタ）
    - 他のアトムからの被参照数
      - アトムリストからは参照されない前提
      - 他のアトムが（他のアトムを参照しようとして間接的に）参照している場合は，
	この Indirection アトムは消去できない
    - Indirection アトムは他のシンボルアトムからの被参照数がゼロの場合はそもそも生成しない
      - 従って，（Indirection アトムの）被参照数はシンボルアトムからの参照数と等価？
      - アトムリストにも登録しない？

** トラバースに関して

*** アトムリストの参照から辿り始めた場合
    - 必ずシンボルアトムを dereference するべき
    - Indirection アトムはアトムリストに登録しないので

*** アトムの引数のリンク（ポインタ）から辿り始めた場合
    - 参照先がシンボルアトムなら普通にマッチする
    - 参照先が Indirection アトムだったらその先を辿る
      - Indirection アトムの被参照数を1減らす
	- アトムの引数からの参照の分
	- これで Indirection アトムの被参照数がゼロになったらメモリを解放
      - Indirection アトムを辿っているうちに普通のアトムに辿り着いたら
	- そのアトムへの参照で元のアトムの引数を更新する
      - Indirection アトムを辿っているうちに自分自身に辿り着くということはあるか？
	（Indirection のみでループしうるか？）
	- 設計が正しければ，そんなことは起きない
	- アトムの引数からは必ずアトムが一つ辿れるはずなので

** Push に関して
   - 被参照数がゼロになるような Indirection はそもそも生成しない
   - Indirection の左辺の自由リンクは局所リンクでマッチしたアトムと同じく，
     アトムリストから除去する
     - 従って，Indirection アトムはアトムリストに登録されない
     - 従って，アトムの参照カウンタはシンボルアトムからの（間接参照も含む）参照数とアトムリストからの参照の分
       の和よりも大きくなることはない
       - つまり，参照カウンタの値がゼロになったら破棄して良い（それ以外に参照しているものはいないことが保証される）
   


* 自由リンクのリダイレクションのチェック 

  自由リンクのリダイレクションは，以下の両方を満たす場合には行なってはいけない

  - 非単射的なマッチングを行っていて
    - 要するにマッチングしたアトムを削除することになる
  - リダイレクションを無理矢理行なった場合に被参照数が 1 以上になる
    - 他からまだ参照されうる場合

** Dactl との違い
  Dactl ではそもそも，リダイレクションを行う自由リンクが非単射的マッチングを行うことを許していない
  （と思われる）

**  プログラム例

  #+NAME: Invalid redirection
  #+BEGIN_SRC sh :dir ../ :exports both :results code :cache yes
    cat example/test3.dhl && echo "------"
    opam exec -- dune exec dhl -- example/test3.dhl
  #+END_SRC

  #+RESULTS[e45ffe86b5bb6a02e9722edea000f6601d5990a5]: Invalid redirection
  #+begin_src sh
  \X.( 
    X -> a(X), b(X)
  ).

  X -> a(Y) :- X -> Y.
  0: b(L0). L0 -> a(L0)
  Final state: b(L0). L0 -> a(L0)
  #+end_src

  これは遷移しない
  
  ただし，これは遷移する（Dactl だと遷移しない）
  
  #+NAME: Valid redirection
  #+BEGIN_SRC sh :dir ../ :exports both :results code :cache yes
    cat example/test4.dhl && echo "------"
    opam exec -- dune exec dhl -- example/test4.dhl
  #+END_SRC  
  

* デバッグ用の Dumper

  =-dbg= オプションをつけると，アトムリストをダンプする

  - アトムリスト上に存在するアトムは 0 から連続する整数のアドレスをふって表示する
    - 全てシンボルアトムであるべき
      （Indirection アトムはアトムリストに登録しない）
  - アトムリストにないアトムは負数のアドレスを振って表示する
    - 全て Indirection アトムであるべき
      （シンボルアトムは必ずアトムリストに登録されているべきなので）
    
  
  #+NAME: Execution with -dbg option  
  #+BEGIN_SRC sh :dir ../ :exports both :results code :cache yes
    opam exec -- dune exec dhl -- example/append.dhl -dbg
  #+END_SRC

  #+RESULTS[4fb386425d289537dd91897a3a55006a5780f44e]: Execution with -dbg option
  #+begin_src sh
  0: 
  #0 -> 1 : nil []
  #1 -> 1 : c []
  #2 -> 1 : nil []
  #3 -> 1 : b []
  #4 -> 1 : cons [#3, #2]
  #5 -> 1 : a []
  #6 -> 0 : append [#8, #7]
  #7 -> 1 : cons [#1, #0]
  #8 -> 1 : cons [#5, #4]

  1: 
  #0 -> 1 : append [#5, #8]
  #1 -> 1 : nil []
  #2 -> 1 : c []
  #3 -> 1 : nil []
  #4 -> 1 : b []
  #5 -> 1 : cons [#4, #3]
  #6 -> 1 : a []
  #7 -> 0 : cons [#6, #0]
  #8 -> 1 : cons [#2, #1]

  2: 
  #0 -> 1 : append [#4, #8]
  #1 -> 1 : cons [#5, #0]
  #2 -> 1 : nil []
  #3 -> 1 : c []
  #4 -> 1 : nil []
  #5 -> 1 : b []
  #6 -> 1 : a []
  #7 -> 0 : cons [#6, #1]
  #8 -> 1 : cons [#3, #2]

  3: 
  #-1 -> 1 : -> [#6]
  #0 -> 1 : cons [#3, #-1]
  #1 -> 1 : nil []
  #2 -> 1 : c []
  #3 -> 1 : b []
  #4 -> 1 : a []
  #5 -> 0 : cons [#4, #0]
  #6 -> 1 : cons [#2, #1]

  Final state: 
  #0 -> 1 : cons [#3, #6]
  #1 -> 1 : nil []
  #2 -> 1 : c []
  #3 -> 1 : b []
  #4 -> 1 : a []
  #5 -> 0 : cons [#4, #0]
  #6 -> 1 : cons [#2, #1]

  #+end_src


  
* Dump.dump に関して

  トポロジカルソートを行う過程で，全ての到達可能なアトムのリストを返すため，
  Indirection アトムも明示的に dump するようになっている

  今はデバッグに便利そうだから放っておいているが，
  あとで Indirection アトムは隠蔽するように変更しても良いかもしれない

  
