#+title: DHL in OCaml
#+subtitle: A minimal interpreter of a language based on graph rewriting
#+author: Jin SANO
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+OPTIONS: ^:nil

* About
  A minimal implementation of a graph rewriting language Directed HyperLMNtal.

** Getting Started
*** Prerequisites
    - [[https://opam.ocaml.org/][opam]]

*** Installation
  #+NAME: Installation
  #+BEGIN_SRC sh
    git clone https://github.com/sano-jin/dhl-in-ocaml
    cd dhl-in-ocaml
    opam install .
    dune build
  #+END_SRC

** Usage

  #+NAME: Usage
  #+BEGIN_SRC sh
    dune exec dhl -- example/append.dhl
  #+END_SRC

   
  
* 実装の概要

  500 LOC 程度の非常に小さいプログラムである
  （ことを目指している）

** LOC
  #+NAME: directory
  #+BEGIN_SRC sh :cache yes :exports results :results code
    cd ../src && ../scripts/cloc.sh "*.ml *.mll *.mly" | tail -n 18
  #+END_SRC
  #+RESULTS[a6c9a9dcab97dbc67780bcf26c773228d0a3b568]: directory
  #+begin_src sh
  -------------------------------------------------------------------------------
  File                             blank        comment           code
  -------------------------------------------------------------------------------
  match.ml                            15             20             86
  vm.ml                               22             23             81
  util.ml                             25              2             60
  parser.mly                          20             12             59
  pushout.ml                           4              2             52
  breakdown.ml                        18             18             51
  dhl.ml                               7              7             39
  link_check.ml                       16             11             39
  alpha.ml                            14             11             34
  lexer.mll                           10              8             34
  eval.ml                              5              4             13
  syntax.ml                            2              3              9
  -------------------------------------------------------------------------------
  SUM:                               158            121            557
  -------------------------------------------------------------------------------
  #+end_src

** Dependencies
   [[../src/output.png]]
   
   
** Source programs

   
   
*** Utility functions 
   - util.ml		:: Some utility functions

*** Compiler

**** Lexical/Syntax analysis
     - syntax.ml	:: The abstract syntax definition
     - lexer.mll	:: Defines a token for lexing
     - parser.mly 	:: Defines a grammar for parsing

**** Semantic analysis
     - alpha.ml		:: Convert local link names to fresh ids and partition atoms and rules
     - link_check.ml	:: Collect link information and check them
     - breakdown.ml	:: Check rule conditions and break down atoms

*** VM
    - vm.ml		:: Type definition of an atom and pretty printer for its multi-set
    - match.m		:: Perform graph pattern matching
    - pushout.ml	:: Generate and push atoms
    - eval.ml		:: The one step reducer

*** Repl
    - main.ml		:: File loader and the main execution loop

  
    
* アトムのメモリ管理に関して
  性能を出すためには，局所リンクでマッチしたアトムや Indirection アトム
  （自由リンクでマッチしてシンボルアトムを置き換える）を毎回アトムリストから削除するよりも，
  Void アトムで更新して，マッチングの際にアトムリストからトラバースする時にアトムリストから取り除き，
  メモリ領域を解放してやる方が良いかもしれない

  現状の方針
  - Indirection アトムはアトムリストに登録しない
  - 局所リンクでマッチしたアトムは毎回アトムリストから除去する
    
** アトムが持つべき情報

*** シンボルアトムの持つべき情報
    - アトム名
    - 引数のリンク（ポインタ）を m 本
    - 他のアトムからの被参照数
      - アトムリストからの参照はカウントしない
      - アトムリストからは常に辿れるはず（べき）なので

*** Indirection アトムの持つべき情報
    - 引数のリンクを一本（ポインタ）
    - 他のアトムからの被参照数
      - アトムリストからは参照されない前提
      - 他のアトムが（他のアトムを参照しようとして間接的に）参照している場合は，
	この Indirection アトムは消去できない
    - Indirection アトムは他のシンボルアトムからの被参照数がゼロの場合はそもそも生成しない
      - 従って，（Indirection アトムの）被参照数はシンボルアトムからの参照数と等価？
      - アトムリストにも登録しない？

** トラバースに関して

*** アトムリストの参照から辿り始めた場合
    - 必ずシンボルアトムを dereference するべき
    - Indirection アトムはアトムリストに登録しないので

*** アトムの引数のリンク（ポインタ）から辿り始めた場合
    - 参照先がシンボルアトムなら普通にマッチする
    - 参照先が Indirection アトムだったらその先を辿る
      - Indirection アトムの被参照数を1減らす
	- アトムの引数からの参照の分
	- これで Indirection アトムの被参照数がゼロになったらメモリを解放
      - Indirection アトムを辿っているうちに普通のアトムに辿り着いたら
	- そのアトムへの参照で元のアトムの引数を更新する
      - Indirection アトムを辿っているうちに自分自身に辿り着くということはあるか？
	（Indirection のみでループしうるか？）
	- 設計が正しければ，そんなことは起きない
	- アトムの引数からは必ずアトムが一つ辿れるはずなので

** Push に関して
   - 被参照数がゼロになるような Indirection はそもそも生成しない
   - Indirection の左辺の自由リンクは局所リンクでマッチしたアトムと同じく，
     アトムリストから除去する
     - 従って，Indirection アトムはアトムリストに登録されない
     - 従って，アトムの参照カウンタはシンボルアトムからの（間接参照も含む）参照数とアトムリストからの参照の分
       の和よりも大きくなることはない
       - つまり，参照カウンタの値がゼロになったら破棄して良い（それ以外に参照しているものはいないことが保証される）
   
