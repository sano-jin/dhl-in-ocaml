#+title: DHL in OCaml
#+subtitle: A minimal interpreter of a language based on graph rewriting
#+author: Jin SANO
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+OPTIONS: ^:nil

* About
  A minimal implementation of a graph rewriting language Directed HyperLMNtal.

** Getting Started
*** Prerequisites
    - [[https://opam.ocaml.org/][opam]]

*** Installation
    #+NAME: Installation
    #+BEGIN_SRC sh
      git clone https://github.com/sano-jin/dhl-in-ocaml
      cd dhl-in-ocaml
      opam install .
      opam exec -- dune build
    #+END_SRC

** Usage

   example/append.dhl  
   #+include: ../example/append.dhl example
   
   #+NAME: Usage
   #+BEGIN_SRC sh :dir ../ :exports both :results code :cache yes
     opam exec -- dune exec dhl -- example/append.dhl
   #+END_SRC

   #+RESULTS[e0c57b8f070978062c17c899b19171f1a61edb52]: Usage
   #+begin_src sh
     0: append(cons(a, cons(b, nil)), cons(c, nil))
     1: cons(a, append(cons(b, nil), cons(c, nil)))
     2: cons(a, cons(b, append(nil, cons(c, nil))))
     3: cons(a, cons(b, L0)). L0 -> L1. L1 -> cons(c, nil)
     Final state: cons(a, cons(b, cons(c, nil)))
   #+end_src

   
* 実装の概要
  500 LOC 程度の非常に小さいプログラムである
  （ことを目指している）
  
** LOC
   #+NAME: directory
   #+BEGIN_SRC sh :exports results :results code :cache yes :dir ../ 
     cd src && ../scripts/cloc.sh "*.ml *.mll *.mly" | tail -n 18
   #+END_SRC

   #+RESULTS[7e2b07c6dea30eca900b78fc802cb319d86aca97]: directory
   #+begin_src sh
   File                             blank        comment           code
   -------------------------------------------------------------------------------
   match.ml                            15             25             95
   util.ml                             24              3             63
   parser.mly                          20             12             59
   breakdown.ml                        19             19             55
   pushout.ml                           6              2             51
   dump.ml                             10             13             48
   main.ml                             11              8             47
   link_check.ml                       16             11             39
   alpha.ml                            14             11             34
   lexer.mll                           10              8             34
   vm.ml                               18             46             34
   eval.ml                              5              5             13
   syntax.ml                            2              3              9
   -------------------------------------------------------------------------------
   SUM:                               170            166            581
   -------------------------------------------------------------------------------
   #+end_src

** Dependencies

   #+name: dependencies
   #+begin_src sh :dir ../ :exports none :cache yes
     python3 ../scripts/dep_graph.py ../src | dot -Tsvg > output.svg
   #+end_src
   
   #+RESULTS: dependencies
   
   [[./output.svg]]
   
** プログラムの簡単な解説

   
   
*** Utility functions 
    - util.ml		:: Some utility functions

*** Compiler

**** Lexical/Syntax analysis
     - syntax.ml	:: The abstract syntax definition
     - lexer.mll	:: Defines a token for lexing
     - parser.mly 	:: Defines a grammar for parsing

**** Semantic analysis
     - alpha.ml		:: Convert local link names to fresh ids and partition atoms and rules
     - link_check.ml	:: Collect link information and check them
     - breakdown.ml	:: Check rule conditions and break down atoms

*** VM
    - vm.ml		:: Type definition of an atom and pretty printer for its multi-set
    - match.m		:: Perform graph pattern matching
    - pushout.ml	:: Generate and push atoms
    - eval.ml		:: The one step reducer

*** Repl
    - main.ml		:: File loader and the main execution loop


* アトムのメモリ管理に関して
  性能を出すためには，局所リンクでマッチしたアトムや Indirection アトム
  （自由リンクでマッチしてシンボルアトムを置き換える）を毎回アトムリストから削除するよりも，
  Void アトムで更新して，マッチングの際にアトムリストからトラバースする時にアトムリストから取り除き，
  メモリ領域を解放してやる方が良いかもしれない

  現状の方針
  - Indirection アトムはアトムリストに登録しない
  - 局所リンクでマッチしたアトムは毎回アトムリストから除去する
    
** アトムが持つべき情報

*** シンボルアトムの持つべき情報
    - アトム名
    - 引数のリンク（ポインタ）を m 本
    - 他のアトムからの被参照数
      - アトムリストからの参照はカウントしない
      - アトムリストからは常に辿れるはず（べき）なので

*** Indirection アトムの持つべき情報
    - 引数のリンクを一本（ポインタ）
    - 他のアトムからの被参照数
      - アトムリストからは参照されない前提
      - 他のアトムが（他のアトムを参照しようとして間接的に）参照している場合は，
	この Indirection アトムは消去できない
    - Indirection アトムは他のシンボルアトムからの被参照数がゼロの場合はそもそも生成しない
      - 従って，（Indirection アトムの）被参照数はシンボルアトムからの参照数と等価？
      - アトムリストにも登録しない？

** トラバースに関して

*** アトムリストの参照から辿り始めた場合
    - 必ずシンボルアトムを dereference するべき
    - Indirection アトムはアトムリストに登録しないので

*** アトムの引数のリンク（ポインタ）から辿り始めた場合
    - 参照先がシンボルアトムなら普通にマッチする
    - 参照先が Indirection アトムだったらその先を辿る
      - Indirection アトムの被参照数を1減らす
	- アトムの引数からの参照の分
	- これで Indirection アトムの被参照数がゼロになったらメモリを解放
	- ……ではダメで，Indirection アトムからたどっているときは，その被参照数分だけ減算する必要がある
      - Indirection アトムを辿っているうちに普通のアトムに辿り着いたら
	- そのアトムへの参照で今まで辿ってきた 0 個以上の Indirection アトムも含めて元のアトムの引数を更新する
      - Indirection アトムを辿っているうちに自分自身に辿り着くということはあるか？
	（Indirection のみでループしうるか？）
	- 設計が正しければ，そんなことは起きない
	- アトムの引数からは必ずアトムが一つ辿れるはずなので

	  

    
** Push に関して
   - 被参照数がゼロになるような Indirection はそもそも生成しない
   - Indirection の左辺の自由リンクは局所リンクでマッチしたアトムと同じく，
     アトムリストから除去する
     - 従って，Indirection アトムはアトムリストに登録されない
     - 従って，アトムの参照カウンタはシンボルアトムからの（間接参照も含む）参照数とアトムリストからの参照の分
       の和よりも大きくなることはない
       - つまり，参照カウンタの値がゼロになったら破棄して良い（それ以外に参照しているものはいないことが保証される）
   

* 自由リンクのリダイレクションのチェック 

  自由リンクのリダイレクションは，以下の両方を満たす場合には行なってはいけない

  - 非単射的なマッチングを行っていて
    - 要するにマッチングしたアトムを削除することになる
  - リダイレクションを無理矢理行なった場合に被参照数が 1 以上になる
    - 他からまだ参照されうる場合

** Dactl との違い
   Dactl ではそもそも，リダイレクションを行う自由リンクが非単射的マッチングを行うことを許していない
   （と思われる）

**  プログラム例

   #+include: ../example/test3.dhl example

   #+NAME: Invalid redirection
   #+BEGIN_SRC sh :dir ../ :exports both :results code :cache yes
     opam exec -- dune exec dhl -- example/test3.dhl
   #+END_SRC

  
   #+RESULTS[26d99a4eded1fb5285063906fce06f4f3875aec9]: Invalid redirection
   #+begin_src sh
     0: b(L0). L0 -> a(L0)
     Final state: b(L0). L0 -> a(L0)
   #+end_src

   これは遷移しない
  
   ただし，これは遷移する（Dactl だと遷移しない）

   #+include: ../example/test4.dhl example
  
   #+NAME: Valid redirection
   #+BEGIN_SRC sh :dir ../ :exports both :results code :cache yes
     opam exec -- dune exec dhl -- example/test4.dhl
   #+END_SRC  

   #+RESULTS[90e3444d4a164f0271997fe477741db0b16894d6]: Valid redirection
   #+begin_src sh
     0: L0 -> a(L0)
     1: 
     Final state: 
   #+end_src
  

* デバッグ用の Dumper

  =-dbg= オプションをつけると，アトムリストをダンプする

  - アトムリスト上に存在するアトムは 0 から連続する整数のアドレスをふって表示する
    - 全てシンボルアトムであるべき
      （Indirection アトムはアトムリストに登録しない）
  - アトムリストにないアトムは負数のアドレスを振って表示する
    - 全て Indirection アトムであるべき
      （シンボルアトムは必ずアトムリストに登録されているべきなので）
    
  
  #+NAME: Execution with -dbg option  
  #+BEGIN_SRC sh :dir ../ :exports both :results code :cache yes
    opam exec -- dune exec dhl -- example/append.dhl -dbg
  #+END_SRC

  #+RESULTS[4fb386425d289537dd91897a3a55006a5780f44e]: Execution with -dbg option
  #+begin_src sh
    0: 
    #0 -> 1 : nil []
    #1 -> 1 : c []
    #2 -> 1 : nil []
    #3 -> 1 : b []
    #4 -> 1 : cons [#3, #2]
    #5 -> 1 : a []
    #6 -> 0 : append [#8, #7]
    #7 -> 1 : cons [#1, #0]
    #8 -> 1 : cons [#5, #4]

    1: 
    #0 -> 1 : append [#5, #8]
    #1 -> 1 : nil []
    #2 -> 1 : c []
    #3 -> 1 : nil []
    #4 -> 1 : b []
    #5 -> 1 : cons [#4, #3]
    #6 -> 1 : a []
    #7 -> 0 : cons [#6, #0]
    #8 -> 1 : cons [#2, #1]

    2: 
    #0 -> 1 : append [#4, #8]
    #1 -> 1 : cons [#5, #0]
    #2 -> 1 : nil []
    #3 -> 1 : c []
    #4 -> 1 : nil []
    #5 -> 1 : b []
    #6 -> 1 : a []
    #7 -> 0 : cons [#6, #1]
    #8 -> 1 : cons [#3, #2]

    3: 
    #-1 -> 1 : -> [#6]
    #0 -> 1 : cons [#3, #-1]
    #1 -> 1 : nil []
    #2 -> 1 : c []
    #3 -> 1 : b []
    #4 -> 1 : a []
    #5 -> 0 : cons [#4, #0]
    #6 -> 1 : cons [#2, #1]

    Final state: 
    #0 -> 1 : cons [#3, #6]
    #1 -> 1 : nil []
    #2 -> 1 : c []
    #3 -> 1 : b []
    #4 -> 1 : a []
    #5 -> 0 : cons [#4, #0]
    #6 -> 1 : cons [#2, #1]

  #+end_src


* Dump.dump に関して

  トポロジカルソートを行う過程で，全ての到達可能なアトムのリストを返すため，
  Indirection アトムも明示的に dump するようになっている

  今はデバッグに便利そうだから放っておいているが，
  あとで Indirection アトムは隠蔽するように変更しても良いかもしれない

  
* マッチングの戦略
  
  #+NAME: Matching environment
  #+BEGIN_SRC ocaml
    type env = {
      matched_atoms: node_ref list;
      (** all the addresses of the matched atoms on lhs *)

      local2addr: (int * node_ref) list;
      free2addr: (string * node_ref) list;
      free_addr2indeg: (node_ref * int) list;
    }
  #+END_SRC

  全体としては，4本のリスト（スタック）を持つことになる（と思われる）
  - ただし，=free_addr2indeg= は実行中にずっと持ち続ける必要はない（かもしれない）

** マッチングを行ったアトムのアドレスの集合
   マッチングを行ったアトムのアドレスは =matched_atoms= に追加する
   - これはアトムへの非単射的なマッチングを防ぐため
   - ファンクタごとに分類した方が効率的である

** リンクからアドレスへの写像
   マッチングに成功したリンクは対応するノードのアドレスとともに持っておき，
   次回からはアトムリストから探索するのではなく dereference を行う
   - この，Dereference を行うかの判断は静的に行うことができる
     （コンパイラのタスクである）

   それぞれ，
   - マッチングに成功した局所リンクは対応するノードのアドレスとともに =local2addr= に登録する
   - マッチングに成功した自由リンクは対応するノードのアドレスとともに =free2addr= に登録する

** 自由リンクから入次数への写像

   これが計算されるのはマッチング終了間際（マッチング自体には成功して，自由リンクの入次数のチェックを行う前）である．

   ただし，失敗したらバックトラックを行う必要があるために，あくまでマッチングの最後として行う必要がある
   - マッチングと分離して，マッチング後に行うようにすることはできない
   
   要改良である
     
   =free_addr2indeg= を持たずに実装可能ではある（と思われる）
   - 自由リンクの入次数チェックを行う前に破壊的代入を行なってしまい，
     チェックを行った結果，ダメだったら再度正負を反転した入次数の差分を代入して戻すという手もある


* メモ
  
